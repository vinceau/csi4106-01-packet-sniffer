---
title: "Project 1: HTTP Header Sniffer"
author: Vincent Au (2016840200)
date: |
    CSI4106-01 Computer Networks (Fall 2016)
header-includes:
    - \usepackage{fullpage}
---

#Introduction

This program prints out the HTTP headers and writes the entity body of POST requests to a text file.

You can compile it using the `make` command or alternatively:

```
gcc -o project_1 project_1.c -std=c99 -lpcap
```

#Program Commentary

The program sniffs network packets using the library pcap (`#include <pcap.h`) using the filter "tcp post 80". We use the function `pcap_loop()` with a count of -1 to continue looping until terminated.

Each time a packet is found, the function `got_packet()` is called. This function checks to see if the packet contains a valid TCP and IP header size before unpacking the packet and the payload. If the size of the payload is 0, we ignore the packet. Otherwise, the payload is passed to the function `classify_packet()` which will determine what kind of HTTP header is contained within the payload.

HTTP Response headers typically start with the "HTTP", for example: `HTTP/1.1 200 OK\r\n`. And so the `classify_packet()` function first checks to see if the payload starts with the text "HTTP" and if so returns the integer value 1, indicating that it is a HTTP Response header.

HTTP Request headers also contain the text "HTTP" but follows after the space-separated type of request and the URL of the request, for example: `HEAD / HTTP/1.1\r\n`. So the function will loop through the first line (by terminating after the `\r\n` characters) of the header, character by character, to determine what the text after the second space character is. If it is "HTTP" it returns the integer value 0, otherwise it returns -1 indicating that the header is either incomplete or isn't supported.

Back in the `got_packet()` function, if a -1 is returned from `classify_packet()` the packet simply gets ignored. Otherwise, we start to print out the information regarding the packet such as the header number as well as source and destination IP address and ports. The main printing of the HTTP header contents is handled by the function `print_payload()`. This function first checks to see if the header is a POST request by checking the first 4 characters of the header. If it is a POST request, it marks the `is_post` flag as true and creates a file with the file name given by `header_num` using the `prep_post()` function. It then continues to print the HTTP header, character by character until it reaches the terminal characters `\r\n\r\n`. If the `is_post` flag is marked, it will start printing the rest of the packet payload, the entity body, into the file that was generated by the `prep_post()` function. Otherwise, the function simply returns, ready to process other packets.

#Current Limitations
Since TCP sends data in streams, it is possible for a HTTP header to be split into multiple packets. The first portion of the header can be recognised by `classify_packet()` however latter portions of the header will not match the predefined rules for classifying packets and hence will have a return value of -1. The program currently has no way of joining together related data that has been split over multiple packets. As a result, although the program can print the entity body of POST requests, it only works for the POST requests with `Content-Type: application/x-www-form-urlencoded` in the header. POST requests with `Content-Type: multipart/form-data` isn't supported since the form data is sent over a separate packet.

#Disclaimer

The ethernet structures and declarations used in this program were inspired and adapted from the [*Programming with pcap*](http://www.tcpdump.org/pcap.html)[^1] tutorial by Tim Carstens of the Tcpdump Group.



[^1]: <http://www.tcpdump.org/pcap.html>
